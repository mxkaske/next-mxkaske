---
title: "Page view counter with upstash"
date: "2022-10-26"
excerpt: "Elaborating Next.js middleware to..."
---

## How to implement a page view counter with Upstash

### Introduction

I really enjoy [@leeerob](https://twitter.com/leeerob)'s blog posts. He implemented a [`ViewCounter`](https://github.com/leerob/leerob.io/blob/main/components/ViewCounter.tsx) that counts the number of views of each of his posts. When opening a post, you will notice a UI shift on the first render as the Component fetches the data on CSR using [`swr`](https://swr.vercel.app).

![leerob blog post](/assets/blog/page-views/leerob-refresh-page-views.gif)

Now, is it possible to disable the shift with the tools provided by Next.js? Yes, by moving the fetch operation at the same time as we generate the static post pages. We leverage `getStaticProps` (see docs "[When does getStaticProps run?](https://nextjs.org/docs/basic-features/data-fetching/get-static-props#when-does-getstaticprops-run)") to add Incremental Static Regeneration and serve a new page with the updated views after X seconds.
Why can't we use a `getServerSideProps`? Simply because we can't use both. For blog posts, we should stick to static sites as they are perfect for SEO. Instead, Next.js allows us to do Incremental Staic Regeneration inside `getStaticProps` which allows us to regenerate the page if it got staled.

We will use a simple redis database powered by [upstash](https://upstash.com) to store the number of views.

### Show the flow

![page view flow](/assets/blog/page-views/excalidraw-flow.png)

Each time a **/writing/blog-post-slug** page is requested, we increment the number of views inside the middleware. Every time the cached revalidate seconds is exceeded, a new static blog post will be generated with the correct number of views. In our example, it will revalidate the page after 60 seconds (and a visitor opens the post).

### Implementation phase

We only require 3 steps to implement the new feature! Let's get cracking.

1. Getting started with Upstash
2. Create the `middleware`
3. Update the `Post` page

#### 1. Getting started with Upstash

If you donâ€™t already have an [Upstash](http://console.upstash.com/) account, create one first. They have a generous free plan to start with - no credit card required. Create a new Redis database and fill out the required inputs.

![upstash create database](/assets/blog/page-views/upstash-create-db.png)

You can easily copy and paste the `UPSTASH_REDIS_REST_URL` and `UPSTASH_REDIS_REST_TOKEN` into your `.env.local` file to start with.

![upstash copy api keys](/assets/blog/page-views/upstash-api-keys.png)

```
// .env.local
UPSTASH_REDIS_REST_URL=<YOUR_URL>
UPSTASH_REDIS_REST_TOKEN=<YOUR_TOKEN>
```

Install the [`@upstash/redis`](https://www.npmjs.com/package/@upstash/redis) package.

```shell
> npm install @upstash/redis
```

#### 2. Create the `middleware`

Your middleware file lies nowadays in the root folder where the `/pages` directory is. For us, it will be `/src/middleware.ts`. The middleware will run the code before the request is completed and the page is returned. We only want to increment the views of the `slug` blog post if the requested pathname starts with **"/writing/"**.

```tsx
// src/middleware.ts
import { Redis } from "@upstash/redis";
import { NextRequest, NextResponse } from "next/server";

const redis = Redis.fromEnv();

const handler = (req: NextRequest) => {
  if (req.nextUrl.pathname.startsWith("/writing/")) {
    const slug = req.nextUrl.searchParams.get("slug"); // param from /pages/writing/[slug].tsx
    redis.incr(`views:${slug}`);
  }
  return NextResponse.next();
};

export default handler;
```

#### 3. Update the `Post` page

The posts are generated in the `src/pages/writing/[slug].tsx` file. We are using [contentlayer](http://contentlayer.dev/) to validate, transform our md/mdx content and include type-safety. I highly recommend it if you are building websites with heavy static content. We get the correct views for the correct slug inside `getStaticProps` and pass it to our `NextPage` Component.

```tsx
// src/pages/writing/[slug].tsx
import { allPosts } from ".contentlayer/generated";
import { GetStaticPropsContext, InferGetStaticPropsType } from "next";
import { Redis } from "@upstash/redis";

export default function Post({
  post,
  views,
}: InferGetStaticPropsType<typeof getStaticProps>) {
  // access the `views` here
  return <div dangerouslySetInnerHTML={{ __html: post.body.html }} />;
}

export const getStaticPaths = async () => {
  return {
    paths: allPosts.map(({ slug }) => ({ params: { slug } })),
    fallback: false,
  };
};

export const getStaticProps = async (context: GetStaticPropsContext) => {
  const slug = context.params.slug as string;
  const redis = Redis.fromEnv();
  const views = ((await redis.get(`views:${slug}`)) || 0) as number;
  const post = allPosts.find((post) => post.slug === slug);
  return {
    props: { post, views },
    revalidate: 60, // 60 seconds - Incremental Static Regeneration
  };
};
```

### Final words

That's it! We have now a view counter implemented with Next.js and Upstash and it will incrementally regenerate our static pages after 60 seconds if someone clicked on it.

If you want to get all the views from your `slugs`, you can easily access them with the redis's [MGET command](https://redis.io/commands/mget/) like:

```ts
// src/pages/writing/index.tsx
export const getStaticProps = () => {
  // ...
  const keys = allPosts.map(({ slug }) => `views:${slug}`);
  const allViews = (await redis.mget(...keys)) as (number | null)[];
  // ...
};
```

That's something I've done for the [/writing](/writing) page that lists all the blog posts.

Also, be aware that the middleware will increment slugs that might not exist. For now, calling **"/writing/xyz"** will create a new "views:xyz" key in our database.
We can avoid that behavior by adding an additional `if` statement:

```ts
// src/middelware.ts
import { allPosts } from ".contentlayer/generated";

const handler = () => {
  // ...
  if (req.nextUrl.pathname.startsWith("/writing/")) {
    const slug = req.nextUrl.searchParams.get("slug");
    // check whether or not the slug exists
    if (allPosts.find((p) => p.slug === slug)) {
      redis.incr(`views:${slug}`);
    }
  }
  // ...
};
```

Thanks for reading and happy hacking!
